Q1. Consider a binary tree of N nodes (1 Root and N−1 descendants). Each node X is
related to the root node by a relation such as L, R, LL, LR, ... and so on, where:
- L  : X is the left child of Root (R).
- R  : X is the right child of Root.
- LL : X is the left child of the left child of Root.
- LR : X is the right child of the left child of Root.
… and so on by extending with L/R.

Write a program to find the sum of all magic parents in the tree.

Definition:
Magic parents are those nodes whose one child is a factor of the other child.
Nodes having only one child can never be Magic parents.

Constraints:
3 ≤ N ≤ 100

Input format:
- The first line contains an integer N, the number of nodes in the tree.
- The second line contains an integer Root, which is the value of the root node.
- The next N−1 lines each contain a string S and an integer X separated by a space,
  where S is the relation between Root and X (e.g., L, R, LL, LR, …), and X is the
  node value at that position.

Output format:
- Print a single integer: the sum of all magic parent node values.

Sample Input
6
11
L 14
R 28
LL 7
LR 8
RR 14

Sample Output
11


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Question: Minimize Operations on a Path (Weighted Tree)

You are given a weighted tree with N nodes and N−1 edges.
In one operation you may choose any edge and either increase its weight by 1
or decrease its weight by 1.

There are Q queries. Each query gives two nodes U and V.
For each query, determine the minimum number of operations required to make
the weights of ALL edges on the unique path from U to V equal.
If U = V, the answer is 0.

Input Format
- The first line contains a single integer N.
- The next N−1 lines each contain three space-separated integers:
  U V W, denoting an edge between nodes U and V with weight W.
- The next line contains a single integer Q.
- The next Q lines each contain two space-separated integers U V
  describing a query path.

Output Format
- Print Q space-separated integers, where the i-th integer is the answer
  to the i-th query.

Constraints
- 1 ≤ N ≤ 1e5
- 1 ≤ U, V ≤ N
- 1 ≤ W ≤ 26
- 1 ≤ Q ≤ 1e5

Sample Input
7
1 2 3
1 3 4
2 4 4
2 5 6
3 6 6
3 7 8
3
2 7
4 6
4 7

Sample Output
5 3 5

Explanation (sketch)
For each query, the minimum number of operations equals the minimum over all
targets t of sum over edges e on the path of |w_e − t|.
This minimum is attained when t is a median of the path’s edge weights.
For (2,7), making all edges equal requires 5 operations; for (4,6) it is 3;
for (4,7) it is 5.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Recursive Land Division

A country consists of N regions, each containing a specific number of towns. 
The government has decided to split the country into two separate nations in a way 
that minimizes the absolute difference between the total number of towns in each new nation.

Each region is connected to another region through roads, forming a tree structure 
(i.e., an undirected connected graph with N-1 edges and no cycles).

Your task is to determine the minimum possible absolute difference in the number of towns 
between the two new nations after removing exactly one road.

Function Description
--------------------
You must implement the following function:

    int minTownDifference(int N, vector<int> towns, vector<pair<int,int>> roads)

Parameters
----------
- int N → The number of regions.
- vector<int> towns → An array of size N, where towns[i] represents the number of towns 
  in the (i+1)th region.
- vector<pair<int,int>> roads → A list of N-1 tuples, where each tuple (u, v) represents 
  a bidirectional road connecting region u and region v.

Returns
-------
- int → The minimum absolute difference in the number of towns between the two new nations 
  after removing exactly one road.

Input Format
------------
- The first line contains one integer, N (the number of regions).
- The second line contains N space-separated integers representing the towns array.
- The next N-1 lines each contain two integers, u and v, representing a bidirectional 
  road between regions u and v.

Constraints
-----------
- 2 ≤ N ≤ 10^5   (Large number of regions)
- 1 ≤ towns[i] ≤ 10^4  (Each region has a significant number of towns)
- 1 ≤ u, v ≤ N   (Valid region indices)
- The given graph is a tree (connected and has no cycles).

Output Format
-------------
A single integer representing the minimum possible absolute difference 
in the number of towns between the two new nations.

Sample Input
------------
4
10 20 10 30
1 2
2 3
3 4

Sample Output
-------------
10

Explanation
-----------
The total number of towns is 10 + 20 + 10 + 30 = 70.

Possible splits:
- Removing (1,2): Two nations → {10}, {20+10+30} → |10 - 60| = 50
- Removing (2,3): Two nations → {10+20}, {10+30} → |30 - 40| = 10
- Removing (3,4): Two nations → {10+20+10}, {30} → |40 - 30| = 10

The minimum possible difference is 10.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Balanced Substrings

Given a string, you need to find the total number of **balanced substrings**. 
A substring is said to be **balanced** if it contains an **equal number of unique vowels** and **unique consonants**.

A vowel is one of the characters: **'a', 'e', 'i', 'o', 'u'**. 
All other lowercase characters are consonants.

Write a function that returns the total number of **balanced substrings** in the string.

Function Signature:
----------------------
long long countBalanced(string &s);

Input:
-------
- A string S consisting of lowercase English letters. The length of the string is denoted by N.

Output:
--------
- A single integer, the total number of **balanced substrings** in the string S.

Constraints:
------------
- 1 ≤ N ≤ 10^5 (The length of the string can be large, so the solution should be efficient)
- The string only contains lowercase English letters (a-z).

Example 1:
-------------
Input: "eef"
Output: 2
Explanation:  
Substrings:
- "e" → vowels = {e} (1), consonants = {} (0) → ❌ not balanced
- "ee" → vowels = {e} (1), consonants = {} (0) → ❌ not balanced
- "eef" → vowels = {e} (1), consonants = {f} (1) → ✅ balanced
- "e" → vowels = {e} (1), consonants = {} (0) → ❌ not balanced
- "ef" → vowels = {e} (1), consonants = {f} (1) → ✅ balanced
- "f" → vowels = {} (0), consonants = {f} (1) → ❌ not balanced

Total balanced substrings = 2

Example 2:
-------------
Input: "ada"
Output: 3
Explanation:
Substrings:
- "a" → vowels = {a} (1), consonants = {} (0) → ❌ not balanced
- "ad" → vowels = {a} (1), consonants = {d} (1) → ✅ balanced
- "ada" → vowels = {a} (1), consonants = {d} (1) → ✅ balanced
- "d" → vowels = {} (0), consonants = {d} (1) → ❌ not balanced
- "da" → vowels = {a} (1), consonants = {d} (1) → ✅ balanced
- "a" → vowels = {a} (1), consonants = {} (0) → ❌ not balanced

Total balanced substrings = 3

Note:
------
- A substring is a contiguous portion of the string.
- The goal is to count all such substrings where the number of unique vowels is equal to the number of unique consonants.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
