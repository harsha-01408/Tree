Q1. Consider a binary tree of N nodes (1 Root and N−1 descendants). Each node X is
related to the root node by a relation such as L, R, LL, LR, ... and so on, where:
- L  : X is the left child of Root (R).
- R  : X is the right child of Root.
- LL : X is the left child of the left child of Root.
- LR : X is the right child of the left child of Root.
… and so on by extending with L/R.

Write a program to find the sum of all magic parents in the tree.

Definition:
Magic parents are those nodes whose one child is a factor of the other child.
Nodes having only one child can never be Magic parents.

Constraints:
3 ≤ N ≤ 100

Input format:
- The first line contains an integer N, the number of nodes in the tree.
- The second line contains an integer Root, which is the value of the root node.
- The next N−1 lines each contain a string S and an integer X separated by a space,
  where S is the relation between Root and X (e.g., L, R, LL, LR, …), and X is the
  node value at that position.

Output format:
- Print a single integer: the sum of all magic parent node values.

Sample Input
6
11
L 14
R 28
LL 7
LR 8
RR 14

Sample Output
11


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Question: Minimize Operations on a Path (Weighted Tree)

You are given a weighted tree with N nodes and N−1 edges.
In one operation you may choose any edge and either increase its weight by 1
or decrease its weight by 1.

There are Q queries. Each query gives two nodes U and V.
For each query, determine the minimum number of operations required to make
the weights of ALL edges on the unique path from U to V equal.
If U = V, the answer is 0.

Input Format
- The first line contains a single integer N.
- The next N−1 lines each contain three space-separated integers:
  U V W, denoting an edge between nodes U and V with weight W.
- The next line contains a single integer Q.
- The next Q lines each contain two space-separated integers U V
  describing a query path.

Output Format
- Print Q space-separated integers, where the i-th integer is the answer
  to the i-th query.

Constraints
- 1 ≤ N ≤ 1e5
- 1 ≤ U, V ≤ N
- 1 ≤ W ≤ 26
- 1 ≤ Q ≤ 1e5

Sample Input
7
1 2 3
1 3 4
2 4 4
2 5 6
3 6 6
3 7 8
3
2 7
4 6
4 7

Sample Output
5 3 5

Explanation (sketch)
For each query, the minimum number of operations equals the minimum over all
targets t of sum over edges e on the path of |w_e − t|.
This minimum is attained when t is a median of the path’s edge weights.
For (2,7), making all edges equal requires 5 operations; for (4,6) it is 3;
for (4,7) it is 5.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Recursive Land Division

A country consists of N regions, each containing a specific number of towns. 
The government has decided to split the country into two separate nations in a way 
that minimizes the absolute difference between the total number of towns in each new nation.

Each region is connected to another region through roads, forming a tree structure 
(i.e., an undirected connected graph with N-1 edges and no cycles).

Your task is to determine the minimum possible absolute difference in the number of towns 
between the two new nations after removing exactly one road.

Function Description
--------------------
You must implement the following function:

    int minTownDifference(int N, vector<int> towns, vector<pair<int,int>> roads)

Parameters
----------
- int N → The number of regions.
- vector<int> towns → An array of size N, where towns[i] represents the number of towns 
  in the (i+1)th region.
- vector<pair<int,int>> roads → A list of N-1 tuples, where each tuple (u, v) represents 
  a bidirectional road connecting region u and region v.

Returns
-------
- int → The minimum absolute difference in the number of towns between the two new nations 
  after removing exactly one road.

Input Format
------------
- The first line contains one integer, N (the number of regions).
- The second line contains N space-separated integers representing the towns array.
- The next N-1 lines each contain two integers, u and v, representing a bidirectional 
  road between regions u and v.

Constraints
-----------
- 2 ≤ N ≤ 10^5   (Large number of regions)
- 1 ≤ towns[i] ≤ 10^4  (Each region has a significant number of towns)
- 1 ≤ u, v ≤ N   (Valid region indices)
- The given graph is a tree (connected and has no cycles).

Output Format
-------------
A single integer representing the minimum possible absolute difference 
in the number of towns between the two new nations.

Sample Input
------------
4
10 20 10 30
1 2
2 3
3 4

Sample Output
-------------
10

Explanation
-----------
The total number of towns is 10 + 20 + 10 + 30 = 70.

Possible splits:
- Removing (1,2): Two nations → {10}, {20+10+30} → |10 - 60| = 50
- Removing (2,3): Two nations → {10+20}, {10+30} → |30 - 40| = 10
- Removing (3,4): Two nations → {10+20+10}, {30} → |40 - 30| = 10

The minimum possible difference is 10.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Balanced Substrings

Given a string, you need to find the total number of **balanced substrings**. 
A substring is said to be **balanced** if it contains an **equal number of unique vowels** and **unique consonants**.

A vowel is one of the characters: **'a', 'e', 'i', 'o', 'u'**. 
All other lowercase characters are consonants.

Write a function that returns the total number of **balanced substrings** in the string.

Function Signature:
----------------------
long long countBalanced(string &s);

Input:
-------
- A string S consisting of lowercase English letters. The length of the string is denoted by N.

Output:
--------
- A single integer, the total number of **balanced substrings** in the string S.

Constraints:
------------
- 1 ≤ N ≤ 10^5 (The length of the string can be large, so the solution should be efficient)
- The string only contains lowercase English letters (a-z).

Example 1:
-------------
Input: "eef"
Output: 2
Explanation:  
Substrings:
- "e" → vowels = {e} (1), consonants = {} (0) → ❌ not balanced
- "ee" → vowels = {e} (1), consonants = {} (0) → ❌ not balanced
- "eef" → vowels = {e} (1), consonants = {f} (1) → ✅ balanced
- "e" → vowels = {e} (1), consonants = {} (0) → ❌ not balanced
- "ef" → vowels = {e} (1), consonants = {f} (1) → ✅ balanced
- "f" → vowels = {} (0), consonants = {f} (1) → ❌ not balanced

Total balanced substrings = 2

Example 2:
-------------
Input: "ada"
Output: 3
Explanation:
Substrings:
- "a" → vowels = {a} (1), consonants = {} (0) → ❌ not balanced
- "ad" → vowels = {a} (1), consonants = {d} (1) → ✅ balanced
- "ada" → vowels = {a} (1), consonants = {d} (1) → ✅ balanced
- "d" → vowels = {} (0), consonants = {d} (1) → ❌ not balanced
- "da" → vowels = {a} (1), consonants = {d} (1) → ✅ balanced
- "a" → vowels = {a} (1), consonants = {} (0) → ❌ not balanced

Total balanced substrings = 3

Note:
------
- A substring is a contiguous portion of the string.
- The goal is to count all such substrings where the number of unique vowels is equal to the number of unique consonants.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem — Tree Updates: Subtree & Complement Adds

You are given a rooted tree with N nodes (1-indexed, root = 1). Each node i has an initial value a[i].
You must process Q update operations of two types and then output the final value of every node.

Operations:
1) "1 X Y" — Add Y to every node in the subtree of node X.
2) "2 X Y" — Add Y to every node NOT in the subtree of node X (i.e., to the complement of subtree(X)).

Input format:
- First line: N Q
- Second line: a1 a2 ... aN  (initial values)
- Next N-1 lines: edges u v (undirected; the given graph is a tree; root is 1)
- Next Q lines: each is an operation "t X Y" where:
    t = 1 → add Y to all nodes in subtree(X)
    t = 2 → add Y to all nodes not in subtree(X)

Output format:
- Print N integers: the final values of nodes 1..N (in order), separated by spaces.

Notes:
- Subtree(X) includes X and all its descendants.
- 1 ≤ X ≤ N.
- The tree is connected and has no cycles.
- Values and Y can be positive, zero, or negative (if not otherwise restricted).

Example:
Input
7 2
1 2 3 4 5 6 7
1 2
1 3
2 4
2 5
3 6
3 7
1 2 10
2 3 5

Output
6 17 3 19 20 6 7


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Compatible Warehouse Pairs in a Weighted Tree

You are given a weighted, undirected tree of N warehouses (nodes), rooted at node 1.
Each edge (u, v) has a positive distance w. For every node v (1-based), you are also given
an integer val[v].

Define distance(u, v) as the sum of edge weights on the unique path between u and v.

A pair (u, v) is called compatible if:
  • u is an ancestor of v in the rooted tree (u lies on the path from 1 to v, u ≠ v), and
  • distance(u, v) ≤ val[v].

Task:
Count the total number of compatible pairs (u, v).

Input Format:
  N
  (N-1) lines follow: u v w      // 1 ≤ u, v ≤ N, edge weight w > 0
  final line: val1 val2 ... valN // values for nodes 1..N

Output Format:
  Print a single integer — the number of compatible pairs.

Notes:
  • The tree is rooted at node 1.
  • Edges are undirected; weights are positive.
  • All node indices are 1-based.

Example
Input:
6
1 6 4
6 5 1
1 2 3
1 4 2
4 3 1
2 1 3 1 5 4

Output:
5

Explanation:
Compatible pairs are:
(1, 6): distance(1,6)=4 ≤ val[6]=4
(1, 5): distance(1,5)=4+1=5 ≤ val[5]=5
(6, 5): distance(6,5)=1 ≤ val[5]=5
(4, 3): distance(4,3)=1 ≤ val[3]=3
(1, 3): distance(1,3)=2+1=3 ≤ val[3]=3
Total = 5.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem — Alice vs Charlie (Path Additions on a Tree)

There are M tourist locations (1…M) connected by M−1 bidirectional roads forming a tree.
Each location i has an initial attraction score Ratings[i].

Ownership:
- Odd indices (1,3,5,…) belong to Alice.
- Even indices (2,4,6,…) belong to Charlie.

There are R visits. Each visit is described by (p, q, w).
For a visit, add w to the attraction score of every node on the unique path from p to q (inclusive).

After applying all visits, let:
S1 = sum of final scores at all odd-indexed nodes (Alice),
S2 = sum of final scores at all even-indexed nodes (Charlie).
Output |S1 − S2|.

Input format
1) Integer M
2) M integers: Ratings[1], …, Ratings[M]
3) M−1 lines: edges u v  (1 ≤ u, v ≤ M)
4) Integer R
5) R lines: p q w  (1 ≤ p, q ≤ M)

Output format
A single integer: |S1 − S2|.

Constraints
1 ≤ M ≤ 100000
1 ≤ R ≤ 1000000
1 ≤ Ratings[i], w ≤ 10^9
1 ≤ u, v, p, q ≤ M

Example
Input
6
1 2 3 4 4 2
1 2
1 3
3 4
3 5
2 6
3
5 4 1
1 6 1
3 5 1

Output
2

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem — Path Population Count on a Tree

You are given a tree with N nodes labeled 1..N. Each node i has an integer population P[i].
You will receive Q queries. For each query (U, V, W), consider the unique simple path from U to V in the tree
(including U and V). Count how many nodes X on this path satisfy P[X] ≤ W. Output this count for each query.

Input Format
1) Integer N
2) N integers: P[1], P[2], ..., P[N]          // populations at nodes 1..N
3) N−1 lines: u v                             // undirected edges of the tree
4) Integer Q
5) Q lines: U V W                             // a query

Output Format
For each query, print a single integer: the number of nodes on the U–V path with population ≤ W.

Notes
- The graph is a tree: connected and acyclic.
- Nodes are 1-indexed.
- Path is inclusive of both endpoints.

Example
Input
5
5 1 4 2 3
1 2
1 3
3 4
3 5
3
2 4 3
5 2 5
4 5 2

Output
2
3
1

Explanation
- Query (2,4,3): path 2–1–3–4 has populations [1,5,4,2] → values ≤ 3 are {1,2} → count = 2
- Query (5,2,5): path 5–3–1–2 has populations [3,4,5,1] → values ≤ 5 are all four → count = 4, but since 5 ≤ 5 holds, count = 4; if you intended strict < W, adjust accordingly.
- Query (4,5,2): path 4–3–5 has populations [2,4,3] → values ≤ 2 are {2} → count = 1


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


In a Salesforce organizational hierarchy, the structure is represented as a tree
with n nodes, each corresponding to a team. A team is called a "key team" if it
is an endpoint of any of the longest communication paths (diameters) within the
hierarchy.

The diameter of a tree is defined as the number of edges in the longest simple
path in the tree.

For all the teams in the hierarchy, determine whether they are key teams or not.
Return a binary array of size n (1-indexed conceptually, but you can use 0-based
in code), where the i-th value is:

    1  if node i is a key team (endpoint of at least one diameter),
    0  otherwise.

-------------------------------------------------------------------------------
Example 1:

Input:
    tree_nodes = 7
    tree_edges = 6
    Edges:
        1 2
        2 3
        3 4
        3 5
        1 6
        1 7

Tree structure (1 connected to 2, 6, 7; 2 connected to 3; 3 connected to 4, 5).

There are four diameters (longest paths) in this tree:
    6–5, 6–4, 7–5, 7–4
The endpoints of these diameters are nodes 4, 5, 6, and 7.

Output:
    [0, 0, 0, 1, 1, 1, 1]

-------------------------------------------------------------------------------
Example 2:

Input:
    tree_nodes = 2
    tree_edges = 1
    Edges:
        2 1

Tree structure: node 1 connected to node 2.
The only diameter is the path 1–2, whose endpoints are 1 and 2.

Output:
    [1, 1]

Both nodes are key teams.

-------------------------------------------------------------------------------
Function Description:

Complete the function isKeyTeam.

    vector<int> isKeyTeam(
        int tree_nodes,
        vector<int> tree_from,
        vector<int> tree_to
    );

Parameters:
    tree_nodes : the number of nodes in the tree (nodes are labeled 1..tree_nodes).
    tree_from  : an array of size tree_edges, where tree_from[i] is one endpoint of edge i.
    tree_to    : an array of size tree_edges, where tree_to[i] is the other endpoint of edge i.

Return:
    A vector<int> of size tree_nodes. The i-th value should be 1 if node (i+1)
    is a key team, otherwise 0.

Constraints:
    1 <= tree_nodes <= 10^5
    |tree_from| = |tree_to| = tree_nodes - 1
    1 <= tree_from[i], tree_to[i] <= tree_nodes

Input Format for Custom Testing:
    The first line contains two integers: tree_nodes and tree_edges.
    Each of the next tree_edges lines contains two integers:
        tree_from[i] and tree_to[i]
    describing an undirected edge between those nodes.



XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem Statement

You are given an undirected tree with N nodes numbered 1 to N.
You start at node 1.

A set S of K nodes is given. You must:
- Start from node 1
- Visit every node in S at least once
- Return back to node 1

Each move consists of going to an adjacent node.
Find the minimum number of moves required.

Input Format
- First line: N K
- Second line: K integers (nodes in S)
- Next N−1 lines: edges u v

Output Format
- Print the minimum number of moves.

Example
N = 8, S = {5, 6}
Edges:
1-2
2-5
2-3
2-6
1-4
4-7
7-8

Output:
6

One optimal walk:
1 → 2 → 5 → 2 → 6 → 2 → 1

Constraints
- 1 ≤ N ≤ 2×10^5
- 0 ≤ K ≤ N
- Tree is connected and acyclic
- 1 ≤ u, v ≤ N
- Time limit: 2 seconds
- Memory limit: 256 MB


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem Statement

You are given an undirected tree with N nodes numbered 1 to N.
A node R is given.

You may choose to start from node 1 or from node R.
You must:
- Start from either node 1 or node R
- Visit every node in set S at least once
- Return to node 1 at the end

Each move consists of moving to an adjacent node.
Find the minimum number of moves required.

Input Format
- First line: N K R
- Second line: K integers (nodes in S)
- Next N−1 lines: edges u v

Output Format
- Print the minimum number of moves.

Example
N = 8, K = 2, R = 1
S = {5, 6}

Edges:
1-2
2-5
2-3
2-6
1-4
4-7
7-8

Output:
6

Constraints
- 1 ≤ N ≤ 2×10^5
- 0 ≤ K ≤ N
- Tree is connected and acyclic
- 1 ≤ u, v ≤ N
- Final node must be 1

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are given a directed tree with n nodes (numbered 1 to n) and exactly n-1 directed edges.
The i-th edge goes from g_from[i] to g_to[i].

You may choose any node as the root. After choosing the root, you want the edges to represent a rooted tree,
meaning every edge should point away from the root (parent → child).

You are allowed to reverse (invert) the direction of any edge. Reversing one edge counts as one inversion.

Your task is to determine the minimum number of inversions required, over all possible choices of the root,
to make all edges point away from the chosen root.

Function:
int getMinInversions(int g_nodes, vector<int> g_from, vector<int> g_to)

Input Format:
- First line: g_nodes and g_edges (where g_edges = g_nodes - 1)
- Next g_edges lines: g_from[i] g_to[i]

Output:
- Return the minimum number of edges that must be inverted.

Constraints:
- 2 <= g_nodes <= 100000
- 1 <= g_from[i], g_to[i] <= g_nodes
- g_from[i] != g_to[i]

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

C - Edge Elimination

You are given a tree (a simple connected acyclic graph) on n vertices. The i-th edge of the tree is between vertices u_i and v_i, and has the value w_i written on it.
Initially, your score is 0.
You can repeatedly perform the following operation:

- Choose an edge (u, v, w) that exists in the tree. This is an edge between u and v with a value of w.
- Add its value w to your score.
- Delete the edge from the tree.
- After deletion, you will be left with two disjoint trees. You must choose to keep one of them and discard the other.

This process will then repeat until there are no more edges that can be deleted in your tree.
Find the minimum possible final score that can be attained.

Input Format
- The first line of input will contain a single integer t, denoting the number of test cases.
- Each test case consists of multiple lines of input:
  - The first line of each test case contains a single integer n, denoting the number of vertices in the tree.
  - The next n-1 lines describe the edges. The i-th of these n-1 lines contains three space-separated integers u_i, v_i and w_i, denoting an edge between u_i and v_i of weight w_i.

Output Format
For each test case, output a single integer, the minimum possible final score that can be attained.

Constraints
- 1 ≤ t ≤ 3·10^4
- 1 ≤ n ≤ 2·10^5
- 1 ≤ u_i, v_i ≤ n
- The input edges describe a tree on the vertex set {1,2,...,n}.
- 1 ≤ w_i ≤ 10^9
- The sum of n over all test cases won't exceed 2·10^5

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

There is a tree with N vertices, numbered 1, 2, ..., N.
For each i (1 ≤ i ≤ N − 1), the i-th edge connects vertices x_i and y_i.

Taro will paint each vertex either white or black. It is not allowed to paint
two adjacent vertices both in black.

Find the number of valid ways to paint all vertices, modulo 10^9 + 7.

Constraints:
- All values in the input are integers.
- 1 ≤ N ≤ 10^5
- 1 ≤ x_i, y_i ≤ N
- The given graph is a tree.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are given a rooted weighted tree with N nodes (rooted at node 1) and Q queries.

Each edge has a positive weight representing the fuel required to travel along it.

For each query, you are given three integers u, v, and c.

There are three cars, all starting from the same node s, and together they have c units of fuel
(which can be distributed arbitrarily among the cars).

The cars must move according to the following rules:
- Car A must reach node u by moving only from parent to child.
- Car B must reach node v by moving only from parent to child.
- Car C must reach the root (node 1) by moving only from child to parent.

Each car consumes fuel equal to the sum of the weights of the edges along its path.

Your task is to determine, for each query, the optimal starting node s such that:
- Both u and v are descendants of s.
- The total fuel required, dist(s,u) + dist(s,v) + dist(s,1), is less than or equal to c.
- Among all valid choices of s, the total fuel consumed is maximized.

If no such node s exists, output 0.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are given an undirected tree with n nodes labeled from 0 to n − 1, and an integer k.

The tree is represented by an array edges of length n − 1, where edges[i] = [ui, vi] indicates an undirected edge between nodes ui and vi.

You may perform at most k operations.

In one operation, you may choose any leaf node (a node with degree exactly 1) and remove that node along with its only edge. After removing a leaf, the tree structure changes and new leaf nodes may appear.

The distance between two nodes is defined as the number of edges on the shortest path between them.

The diameter of a tree is defined as the maximum distance between any pair of nodes.

Your goal is to perform at most k leaf-deletion operations such that the diameter of the remaining tree is minimized.

Return the minimum possible diameter of the tree after performing at most k operations.

Constraints:
- 1 ≤ n ≤ 10^5
- edges.length = n − 1
- 0 ≤ ui, vi < n
- 0 ≤ k ≤ n − 1
- The input graph is guaranteed to be a tree.

Example 1:
Input:
n = 4
edges = [[0,1],[1,2],[2,3]]
k = 1

Output:
1

Explanation:
The original diameter is 3 (path 0–1–2–3).
By deleting leaf node 0 or node 3, the remaining tree has diameter 1.

Example 2:
Input:
n = 7
edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[5,6]]
k = 2

Output:
2

Explanation:
By optimally deleting two leaf nodes, the longest path in the remaining tree has length 2.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are given a Binary Tree and an integer k.

Find the length of the longest path in the tree such that for every pair of
consecutive nodes (u, v) on the path:

    |value(u) − value(v)| = k

The path can start and end at any node in the tree.

Constraints:
- The size of the tree can be very large.
- An optimized solution is expected (brute force will not work).
- Recursive / Tree-DP based thinking is required.

Follow-up 1:
The longest path should form a strict arithmetic progression of numbers
(i.e., the difference between consecutive nodes must be exactly +k or exactly -k
and must be consistent throughout the path).

Follow-up 2:
Solve the same problem for a General Tree (N-ary Tree) instead of a Binary Tree.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem Description

You are given an undirected tree representing dependencies between products. The tree consists of
treeNodes nodes labeled from 0 to treeNodes − 1. The edges of the tree are described by two arrays,
treeFrom and treeTo, each of length treeNodes − 1, where treeFrom[i] and treeTo[i] denote an edge
between those two nodes.

A triplet of nodes (i, j, k) is considered valid if it satisfies the following conditions:
1. 0 ≤ i < j < k < treeNodes
2. There is no single simple path in the tree that contains all three nodes i, j, and k.

Your task is to determine the total number of such valid triplets.

Because the number of valid triplets can be very large, return the result modulo 10^9 + 7.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

The question is asking you to design an algorithm to choose a set of “seed” users in a social network under a budget constraint so that the total value of influenced users is maximized.
Here’s the plain-English breakdown:
What you’re given

A social network graph

   * connections: edges between users (an undirected graph).

Seed costs

   * costs[user]: how much it costs to pick that user as a seed.
   * Only users listed here can be chosen as seeds.

User values

   * values[user]: the market value of each user.

A budget

   * Total cost of selected seeds must not exceed this.

A depth d

   * Influence spreads from seeds to their neighbors, neighbors-of-neighbors, etc., up to distance d.
What influence means

If a user is selected as a seed, they are influenced.
All users within distance ≤ d from any seed are also influenced.
Each user’s value is counted once, even if reached by multiple seeds.

What you must compute
Choose a subset of seed users such that:

The sum of their costs ≤ budget
The total market value of all unique influenced users is maximized

Important constraint

Brute force is infeasible (checking all subsets of seeds).
You are expected to use a heuristic or approximation algorithm, not an exact exponential solution.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

It’s asking you to choose which edges to keep so the graph stays connected with exactly n−1 edges, and the bitwise OR of the kept edges’ weights is as small as possible.
More plainly:

• You start with a connected, undirected weighted graph with n nodes and m edges.

• You must remove exactly m−(n−1) edges, which means you will keep exactly n−1 edges.

• Keeping n−1 edges and staying connected means the remaining edges form a spanning tree.

• Define the “beauty” of a spanning tree as:

w₁ | w₂ | … | wₙ₋₁
(bitwise OR of its edge weights)

✅ Goal: Find the minimum possible beauty among all spanning trees of the graph, and print it for each test case.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
